// We need to manually mark what our kernel names are
#pragma kernel ParticleFunction

//let's give ourselves a million threads - 10 * 10 * 10 * 10 * 10 * 10
#define thread_group_x 64
#define thread_group_y 16
#define thread_group_z 1
#define thread_x 64
#define thread_y 16
#define thread_z 1

//Note that this has to match EXACTLY the struct we define in ComputeExample.cs!
struct ParticleData {
	float3 pos;
	float3 velocity;
	float4 color;
	int isAlive;
};

RWStructuredBuffer<ParticleData> outputBuffer;

[numthreads(64, 16, 1)]
void ParticleFunction(uint3 id : SV_DispatchThreadID)
{
	//First we calculate our position in the buffer, and pull the relevant particle out for computation
	int idx = id.x + (id.y * thread_group_x * thread_x) + (id.z * thread_group_x * thread_x * thread_group_y * thread_y);
	ParticleData ThisParticle = outputBuffer[idx];

	if (length(ThisParticle.velocity) > 0) {
		float4 col = float4(normalize(ThisParticle.velocity), 1.0) + float4(1.0, 1.0, 1.0, 1.0);
		col *= 0.5;
		if (length(col) > 0.8) { col.x = 1.0 - col.x; }
		col.a = 1.0;
		ThisParticle.color = col;
	}

	ThisParticle.color = float4(1.0 - ThisParticle.isAlive, 1, 1, 1) * ThisParticle.isAlive + float4(0.1, 0.1, 0.1, 1);
	ThisParticle.color.a = 1;

	//And finally, push the updated particle to the buffer
	outputBuffer[idx] = ThisParticle;
}