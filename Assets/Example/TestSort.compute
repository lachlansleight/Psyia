// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Sort

struct ParticleData {
	float3 pos;
	float3 velocity;
	float4 color;
	int isAlive;
	float age;
};

RWStructuredBuffer<float> distanceBuffer;
RWStructuredBuffer<ParticleData> outputBuffer;

int ButterflyStep;
int SubStep;
int MergeStep;
int CreateBitonic;

[numthreads(1024,1,1)]
void Sort (uint3 tid : SV_GroupThreadID, uint3 gid : SV_GroupID)
{
	uint CurrentIndex = tid.x + 1024 * gid.x;

	if (CreateBitonic) {
		uint CurrentSize = pow(2, ButterflyStep - SubStep);
		uint ButterflySize = pow(2, ButterflyStep);

		uint TargetIndex = CurrentIndex + CurrentSize;
		bool Skip = CurrentIndex % (CurrentSize * 2) > (CurrentSize - 1);
		bool Ascending = (uint)floor(CurrentIndex / (ButterflySize * 2)) % 2 > 0;

		if (!Skip) {
			float a = distanceBuffer[CurrentIndex];
			float b = distanceBuffer[TargetIndex];

			ParticleData pA = outputBuffer[CurrentIndex];
			ParticleData pB = outputBuffer[TargetIndex];

			if (a < b != Ascending) {
				distanceBuffer[CurrentIndex] = b;
				distanceBuffer[TargetIndex] = a;

				outputBuffer[CurrentIndex] = pB;
				outputBuffer[TargetIndex] = pA;
			}
		}
	}
	else {
		uint CurrentSize = pow(2, MergeStep);

		uint TargetIndex = CurrentIndex + CurrentSize;
		bool Skip = (uint)floor(CurrentIndex / CurrentSize) % 2 > 0;
		
		if (!Skip) {
			float a = distanceBuffer[CurrentIndex];
			float b = distanceBuffer[TargetIndex];

			ParticleData pA = outputBuffer[CurrentIndex];
			ParticleData pB = outputBuffer[TargetIndex];

			if (a > b) {
				distanceBuffer[CurrentIndex] = b;
				distanceBuffer[TargetIndex] = a;

				outputBuffer[CurrentIndex] = pB;
				outputBuffer[TargetIndex] = pA;
			}
		}
	}
}
