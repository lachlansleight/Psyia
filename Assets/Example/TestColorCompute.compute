// We need to manually mark what our kernel names are
#pragma kernel ParticleFunction

//let's give ourselves a million threads - 10 * 10 * 10 * 10 * 10 * 10
#define thread_group_x 1024
#define thread_group_y 1
#define thread_group_z 1
#define thread_x 1024
#define thread_y 1
#define thread_z 1

//Note that this has to match EXACTLY the struct we define in ComputeExample.cs!
struct ParticleData {
	float3 pos;
	float3 velocity;
	float4 color;
	int isAlive;
	float age;
};

RWStructuredBuffer<ParticleData> outputBuffer;

 float Lifespan;

[numthreads(1024, 1, 1)]
void ParticleFunction(uint3 tid : SV_GroupThreadID, uint3 gid : SV_GroupID)
{
	//First we calculate our position in the buffer, and pull the relevant particle out for computation
	int id = tid.x + thread_group_x * gid.x;
	ParticleData ThisParticle = outputBuffer[id];

	if (ThisParticle.isAlive == 0) {
		ThisParticle.color = float4(0, 0, 0, 0);
		outputBuffer[id] = ThisParticle;
		return;
	}

	if (length(ThisParticle.velocity) > 0) {
		float4 col = float4(normalize(ThisParticle.velocity), 1.0) + float4(1.0, 1.0, 1.0, 1.0);
		col *= 0.5;
		if (length(col) > 0.8) { col.x = 1.0 - col.x; }
		col.a = saturate(Lifespan - ThisParticle.age - 0.5);
		ThisParticle.color = col;
	}

	//ThisParticle.color.a = ThisParticle.isAlive;

	//And finally, push the updated particle to the buffer
	outputBuffer[id] = ThisParticle;
}