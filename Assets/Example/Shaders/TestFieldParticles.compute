// We need to manually mark what our kernel names are
#pragma kernel ParticleFunction
#include "Assets/AssetPackages/ShaderNoise/HLSL/SimplexNoise3D.hlsl"

//let's give ourselves a million threads - 10 * 10 * 10 * 10 * 10 * 10
#define thread_group_x 1024
#define thread_group_y 1
#define thread_group_z 1
#define thread_x 1024
#define thread_y 1
#define thread_z 1

//controller positions
float4 LeftController;
float4 RightController;
float4 Headset;

//Physics Parameters:
float Damping;
float ParticleCharge;
float ParticleMass;
float SofteningFactor;

//time parameters
float Lifespan;
float Time;
float DeltaTime;

//force field parameters
float3 FieldStartPos;
float3 FieldEndPos;
float3 FieldCount;

//noise parameters
float NoiseAnimationSpeed;
float NoiseStrength;
float NoiseScale;
float NoiseAmount;

//Note that this has to match EXACTLY the struct we define in ComputeExample.cs!
struct ParticleData {
	float3 pos;
	float3 velocity;
	float4 color;
	int isAlive;
	float age;
};

struct DistanceData {
	int index;
	float distance;
};

struct FieldStruct {
	float4 pos;
	float4 instantForce;
	float4 attenuatingForce;
};

RWStructuredBuffer<ParticleData> outputBuffer;
AppendStructuredBuffer<uint> deadList;
RWStructuredBuffer<DistanceData> distanceBuffer;
RWStructuredBuffer<FieldStruct> forceField;

float InverseLerp(float a, float b, float t) {
	return saturate((t - a) / (b - a));
}

float3 GetPotential(float3 p) {
	float3 pot = float3(0,0,0);

	float L = 20;

	pot += L * float3(
		snoise(float4(p.x, p.y,       p.z,      Time * NoiseAnimationSpeed) / L),
		snoise(float4(p.x, p.y + 43,  p.z,      Time * NoiseAnimationSpeed) / L),
		snoise(float4(p.x, p.y,       p.z + 43, Time * NoiseAnimationSpeed) / L)
	);

	return pot;
}

float3 GetNoiseVelocity(float3 p, float scale) {
	p /= scale;

	float epsilon = 0.0001;
	float3 pot = GetPotential(p);
	float dp3_dy = (pot.z - GetPotential(float3(p.x, p.y + epsilon, p.z))).z / epsilon;
	float dp2_dz = (pot.y - GetPotential(float3(p.x, p.y, p.z + epsilon))).y / epsilon;
	float dp1_dz = (pot.x - GetPotential(float3(p.x, p.y, p.z + epsilon))).x / epsilon;
	float dp3_dx = (pot.z - GetPotential(float3(p.x + epsilon, p.y, p.z))).z / epsilon;
	float dp2_dx = (pot.y - GetPotential(float3(p.x + epsilon, p.y, p.z))).y / epsilon;
	float dp1_dy = (pot.x - GetPotential(float3(p.x, p.y + epsilon, p.z))).x / epsilon;

	return float3(dp3_dy - dp2_dz, dp1_dz - dp3_dx, dp2_dx - dp1_dy);
}

float3 GetNoiseVelocitySum(float3 p, int octaves) {
	float3 Sum = float3(0,0,0);
	float3 CurrentP = p;
	float CurrentScale = 1.;
	for(int i = 0; i < octaves; i++) {
		Sum += GetNoiseVelocity(CurrentP, CurrentScale);
		CurrentScale *= 0.5;
	}
	return Sum / octaves;
}

[numthreads(1024, 1, 1)]
void ParticleFunction(uint3 tid : SV_GroupThreadID, uint3 gid : SV_GroupID)
{
	//First we calculate our position in the buffer, and pull the relevant particle out for computation
	int id = tid.x + thread_group_x * gid.x;
	ParticleData ThisParticle = outputBuffer[id];

	if (ThisParticle.isAlive == 0) {
		ThisParticle.pos = float3(0, -10000, 0);
		//ThisParticle.pos = float3(((float)id / 1024.) * 2.5, 2, -0.1);
		outputBuffer[id] = ThisParticle;
		//distanceBuffer[id].index = id;
		//distanceBuffer[id].distance = 10000;
		return;
	}

	ThisParticle.age += DeltaTime;

	if (ThisParticle.age > Lifespan) {
		deadList.Append(id);
		ThisParticle.isAlive = false;
		outputBuffer[id] = ThisParticle;
		return;
	}

	float3 FieldIndexVector = ThisParticle.pos.xyz;
	FieldIndexVector += ((FieldEndPos - FieldStartPos) / FieldCount) * 0.5;
	FieldIndexVector /= (FieldEndPos - FieldStartPos);
	FieldIndexVector += float3(0.5, 0, 0.5);
	FieldIndexVector *= FieldCount;
	FieldIndexVector = float3(floor(FieldIndexVector.x), floor(FieldIndexVector.y), floor(FieldIndexVector.z));
	 
	int FinalIndex = (int)(FieldIndexVector.x * FieldCount.y * FieldCount.z + FieldIndexVector.y * FieldCount.z + FieldIndexVector.z);

	float3 FieldForce = forceField[FinalIndex].instantForce.xyz + forceField[FinalIndex].attenuatingForce.xyz;

	

	//And we get a damping force
	float3 DampingForce = -1.0 * ThisParticle.velocity * Damping;

	//Now we apply the force as acceleration (using newton's second law)
	ThisParticle.velocity += (FieldForce / ParticleMass);
	ThisParticle.velocity += (DampingForce / ParticleMass);

	float3 NewPos = ThisParticle.pos + ThisParticle.velocity;

	//apply walls
	if (NewPos.x < FieldStartPos.x || NewPos.x > FieldEndPos.x) {
		ThisParticle.velocity.x *= -1;
	}
	if (NewPos.y < FieldStartPos.y || NewPos.y > FieldEndPos.y) {
		ThisParticle.velocity.y *= -1;
	}
	if (NewPos.z < FieldStartPos.z || NewPos.z > FieldEndPos.z) {
		ThisParticle.velocity.z *= -1;
	}

	float3 TurbulenceVelocity = normalize(GetNoiseVelocity(ThisParticle.pos, NoiseScale)) * length(ThisParticle.velocity);

	//And we update position
	ThisParticle.pos += lerp(ThisParticle.velocity, TurbulenceVelocity, NoiseAmount);

	//distanceBuffer[id].index = id;
	//distanceBuffer[id].distance = length(ThisParticle.pos - Headset.xyz);

	//And finally, push the updated particle to the buffer
	outputBuffer[id] = ThisParticle;
}