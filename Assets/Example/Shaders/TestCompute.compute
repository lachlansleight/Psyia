// We need to manually mark what our kernel names are
#pragma kernel ParticleFunction

//let's give ourselves a million threads - 10 * 10 * 10 * 10 * 10 * 10
#define thread_group_x 1024
#define thread_group_y 1
#define thread_group_z 1
#define thread_x 1024
#define thread_y 1
#define thread_z 1

//controller positions
float4 LeftController;
float4 RightController;
float4 Headset;

//Physics Parameters:
float Damping;
float ParticleCharge;
float ParticleMass;
float SofteningFactor;

//time parameters
float Lifespan;
float Time;
float DeltaTime;

//Note that this has to match EXACTLY the struct we define in ComputeExample.cs!
struct ParticleData {
	float3 pos;
	float3 velocity;
	float4 color;
	int isAlive;
	float age;
};

struct DistanceData {
	int index;
	float distance;
};

RWStructuredBuffer<ParticleData> outputBuffer;
AppendStructuredBuffer<uint> deadList;
RWStructuredBuffer<DistanceData> distanceBuffer;

[numthreads(1024, 1, 1)]
void ParticleFunction(uint3 tid : SV_GroupThreadID, uint3 gid : SV_GroupID)
{
	//First we calculate our position in the buffer, and pull the relevant particle out for computation
	int id = tid.x + thread_group_x * gid.x;
	ParticleData ThisParticle = outputBuffer[id];

	if (ThisParticle.isAlive == 0) {
		ThisParticle.pos = float3(0, -10000, 0);
		//ThisParticle.pos = float3(((float)id / 1024.) * 2.5, 2, -0.1);
		outputBuffer[id] = ThisParticle;
		//distanceBuffer[id].index = id;
		//distanceBuffer[id].distance = 10000;
		return;
	}

	ThisParticle.age += DeltaTime;

	if (ThisParticle.age > Lifespan) {
		deadList.Append(id);
		ThisParticle.isAlive = false;
		outputBuffer[id] = ThisParticle;
		return;
	}

	//Let's split up our real-time input data into position and charge
	float3 LeftPosition = LeftController.xyz;
	float3 RightPosition = RightController.xyz;
	float LeftCharge = LeftController.w;
	float RightCharge = RightController.w;

	//Now let's calculate some values we're going to use multiple times (to save performance)
	//Note that we add softening factor to distances so that in Coloumb's Law below we don't end up dividing by a very small number, resulting in a ridiculously huge force
	float3 LeftDisplacement = ThisParticle.pos - LeftPosition;
	float3 RightDisplacement = ThisParticle.pos - RightPosition;
	float LeftDistance = length(LeftDisplacement) + SofteningFactor;
	float RightDistance = length(RightDisplacement) + SofteningFactor;

	//Time for the physics!

	//Coloumb's Law (attraction between two charge particles): F = k * (q1 * q2) / (r^2)
	//q1 is our controller charge, q2 is our particle charge, and r is the distance value we calculated earlier
	//we are ignoring k, which is just a scaling constant (it's about 9 billion)
	//remember that opposites attract!
	float3 LeftForce = normalize(LeftDisplacement) * ((LeftCharge * ParticleCharge) / (LeftDistance * LeftDistance));
	float3 RightForce = normalize(RightDisplacement) * ((RightCharge * ParticleCharge) / (RightDistance * RightDistance));

	//And we get a damping force
	float3 DampingForce = -1.0 * ThisParticle.velocity * Damping;

	//Now we apply the force as acceleration (using newton's second law)
	ThisParticle.velocity += (LeftForce / ParticleMass);
	ThisParticle.velocity += (RightForce / ParticleMass);
	ThisParticle.velocity += (DampingForce / ParticleMass);

	//And we update position
	ThisParticle.pos += ThisParticle.velocity;

	//distanceBuffer[id].index = id;
	//distanceBuffer[id].distance = length(ThisParticle.pos - Headset.xyz);

	//And finally, push the updated particle to the buffer
	outputBuffer[id] = ThisParticle;
}