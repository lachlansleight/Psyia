// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Physics
#pragma kernel Graphics

#define thread_group_x 10
#define thread_group_y 10
#define thread_group_z 10

#define thread_x 10
#define thread_y 10
#define thread_z 10

//input data:

//controller and head positions
float4 attractor0;
float4 attractor1;
float4 attractor2;
float4 attractor3;
float4 attractor4;
float4 attractor5;
float4 attractor6;
float4 attractor7;
float4 attractor8;
float4 attractor9;
float4 attractor10;
float4 attractor11;
float4 attractor12;
float4 attractor13;
float4 attractor14;
float4 attractor15;
float4 attractor16;
float4 attractor17;
float4 attractor18;
float4 attractor19;

//time parameters
float timeScale;
float fps;
float time;

//physics parameters
float velocityDampening;
float softeningFactor;
float particleMass;
float vortexStrength;
float3 shipSize;

//visual parameters
int colorMode;

float heightCenter;

struct StarData {
	float3 pos;
	float3 velocity;
	float3 scale;
	float4 color;
	float4 randomSeed;
	float4 anchor;
	float age;
};

RWStructuredBuffer<StarData> outputBuffer;

float3 getForceFromAttractor(float4 attractor, float3 pos, float charge) {
	float gravConst = 0.000006674;

	float3 dist = attractor.xyz - pos;
	float len = length(dist);
	float3 norm = normalize(dist);
	float mag = attractor.w * gravConst * charge / (len + softeningFactor);

	float3 directForce = norm * mag;

	float3 omega = mag * normalize(attractor.xyz - float3(0, heightCenter, 0));
	float3 vortexForce = cross(omega, dist);

	return (directForce + vortexForce * vortexStrength) * 90.0;
}

[numthreads(10, 10, 10)]
void Physics(uint3 id : SV_DispatchThreadID)
{
	int idx = id.x + (id.y * thread_group_x * thread_x) + (id.z * thread_group_x * thread_y * thread_group_y * thread_z);
	StarData curCube = outputBuffer[idx];

	float finalTimeScale = timeScale * (90.0 / fps);

	float gravConst = 0.000006674;

	float3 dampingForce = -1.0 * curCube.velocity * velocityDampening;

	float3 forceSum = float3(0, 0, 0);
	if (attractor0.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor0, curCube.pos, curCube.anchor.x); }
	if (attractor1.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor1, curCube.pos, curCube.anchor.x); }
	if (attractor2.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor2, curCube.pos, curCube.anchor.x); }
	if (attractor3.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor3, curCube.pos, curCube.anchor.x); }
	if (attractor4.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor4, curCube.pos, curCube.anchor.x); }
	if (attractor5.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor5, curCube.pos, curCube.anchor.x); }
	if (attractor6.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor6, curCube.pos, curCube.anchor.x); }
	if (attractor7.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor7, curCube.pos, curCube.anchor.x); }
	if (attractor8.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor8, curCube.pos, curCube.anchor.x); }
	if (attractor9.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor9, curCube.pos, curCube.anchor.x); }
	if (attractor10.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor10, curCube.pos, curCube.anchor.x); }
	if (attractor11.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor11, curCube.pos, curCube.anchor.x); }
	if (attractor12.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor12, curCube.pos, curCube.anchor.x); }
	if (attractor13.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor13, curCube.pos, curCube.anchor.x); }
	if (attractor14.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor14, curCube.pos, curCube.anchor.x); }
	if (attractor15.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor15, curCube.pos, curCube.anchor.x); }
	if (attractor16.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor16, curCube.pos, curCube.anchor.x); }
	if (attractor17.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor17, curCube.pos, curCube.anchor.x); }
	if (attractor18.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor18, curCube.pos, curCube.anchor.x); }
	if (attractor19.w > 0) { forceSum = forceSum + getForceFromAttractor(attractor19, curCube.pos, curCube.anchor.x); }

	//curCube.velocity = curCube.velocity + straightVelocity;

	curCube.velocity = curCube.velocity + (forceSum / particleMass) * finalTimeScale;
		
	curCube.velocity = curCube.velocity + (dampingForce / particleMass) * finalTimeScale;

	//Update position
	curCube.pos = curCube.pos + (curCube.velocity * finalTimeScale);

	if (curCube.pos.y < 0) {
		curCube.pos.y = 0;
		curCube.velocity.y = curCube.velocity.y * -0.8;
	}

	curCube.age = curCube.age + finalTimeScale / fps;

	//Update buffer
	outputBuffer[idx] = curCube;
}



[numthreads(10, 10, 10)]
void Graphics(uint3 id : SV_DispatchThreadID)
{
	//Get current ID
	int idx = id.x + (id.y * thread_group_x * thread_x) + (id.z * thread_group_x * thread_y * thread_group_y * thread_z);
	StarData curCube = outputBuffer[idx];

	//Get Color
	float4 col = float4(1, 1, 1, 1);

	if (colorMode == 0) {
		if (length(curCube.velocity) > 0) {
			//Turn color into vector
			col = float4(normalize(curCube.velocity), 1.0) + float4(1.0, 1.0, 1.0, 1.0);
			col *= 0.5;
			if (length(col) > 0.8) { col.x = 1.0 - col.x; }
			col.a = 1.0;
			curCube.color = lerp(curCube.color, col, 0.1);
		}
	}
	else {
		float3 colA = float3(1,0,0);
		float3 colB = float3(0,1,0);

		if (colorMode == 1) {
			colA = float3(255, 0, 0) / 255.0;
			colB = float3(255, 206, 0) / 255.0;
		}
		else if (colorMode == 2) {
			colA = float3(0, 2, 255) / 255.0;
			colB = float3(0, 213, 255) / 255.0;
		}
		else if (colorMode == 3) {
			colA = float3(40, 186, 161) / 255.0;
			colB = float3(230, 255, 0) / 255.0;
		}
		else if (colorMode == 4) {
			colA = float3(199, 255, 239) / 255.0;
			colB = float3(163, 190, 255) / 255.0;
		}

		if (length(curCube.velocity) > 0) {
			float3 normVel = normalize(curCube.velocity) + float3(1, 1, 1);
			normVel *= 0.5;
			col = float4(lerp(colA.x, colB.x, normVel.x), lerp(colA.y, colB.y, normVel.y), lerp(colA.z, colB.z, normVel.z), 1.0);
			curCube.color = lerp(curCube.color, col, 0.1);
		}
	}

	if (time < 7) {
		//curCube.color = lerp(float4(0, 0, 0, 1), col, saturate(time - 5.0));
	}

	curCube.scale = shipSize;

	//Update buffer
	outputBuffer[idx] = curCube;
}