// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Physics
#pragma kernel Graphics

#define thread_group_x 32
#define thread_group_y 32
#define thread_group_z 1

#define thread_x 32
#define thread_y 32
#define thread_z 1

//input data:

//controller and head positions
float4 controllerPositionL;
float4 controllerForwardL;
float4 controllerVelocityL;
float controllerChargeL;

float4 controllerPositionR;
float4 controllerForwardR;
float4 controllerVelocityR;
float controllerChargeR;

//Audio input
float bassAudio;
float midAudio;
float trebleAudio;
float avgAudio;

//Spawn parameters
float spawnRangeMin;
float spawnRangeMax;
float LRSpawnBalance;

//time parameters
float timeScale;
float fps;
float time;

//physics parameters
float velocityDampening;
float softeningFactor;
float particleMass;
float distanceExponent;
float vortexStrength;
float cubeSpawnVelocity;
//note - these were hard to tune, so I think I'll leave them hardcoded
//float minAnchorVelocity;
//float anchorSetSpeed;
//float maxK;
//float breakForce;
int roomCollision;
int jellyMode;
float3 roomSize;
float3 shipSize;

//visual parameters
int colorMode;

int customMode;
float burstLaunchVelocity;
float returnPullForce;

struct StarData {
	float4 pos;
	float4 velocity;
	float4 scale;
	float4 color;
	float4 randomSeed;
	float4 anchor;
};

RWStructuredBuffer<StarData> outputBuffer;
RWStructuredBuffer<StarData> spawnBuffer;

[numthreads(32, 32, 1)]
void Physics(uint3 id : SV_DispatchThreadID)
{
	int idx = id.x + (id.y * thread_group_x * thread_x) + (id.z * thread_group_x * thread_y * thread_group_y * thread_z);
	StarData curCube = outputBuffer[idx];

	float3 pos = curCube.pos.xyz;
	float age = curCube.pos.w;
	float3 velocity = curCube.velocity.xyz;
	float3 scale = curCube.scale.xyz;

	float finalTimeScale = timeScale * (90.0 / fps);

	//pause
	if (customMode == -1) {
		return;
	}

	//disperse
	if (customMode == 1) {
		pos = float3(0, 1.2, 0);
		velocity = curCube.randomSeed.xyz * burstLaunchVelocity;
		curCube.pos = float4(pos, 0);
		curCube.velocity = float4(velocity, 0);
		outputBuffer[idx] = curCube;
		return;
	}
	//go back to 0,1.2,0
	else if (customMode == 2) {
		float3 returnDisp = float3(0, 1.2, 0) - pos;
		float3 returnNorm = normalize(returnDisp);
		float returnMag = length(returnDisp);


		float forceMagnitude = returnPullForce / (returnMag + softeningFactor);

		float3 vortexForce;

		float3 returnForce = returnNorm * forceMagnitude;

		//add vortex
		//if (returnMag > 0.25) {
		//	returnForce = returnForce + cross(float3(0, forceMagnitude, 0), returnDisp * (1.0 + softeningFactor));
		//}
		
		if (time > 5) {
			velocity = velocity + (returnForce / particleMass) * finalTimeScale;
		}

		//make sure we don't overshoot by clamping velocity as we approach
		float3 newReturnDisp = float3(0, 1.2, 0) - (pos + (velocity * finalTimeScale));
		if (returnMag < length(newReturnDisp) && time > 5) {
			velocity = (float3(0, 1.2, 0) - pos) / finalTimeScale;
		}

		if (time > 5) {
			pos = pos + (velocity * finalTimeScale);
		}

		curCube.pos = float4(pos, 0);
		curCube.velocity = float4(velocity, 0);

		outputBuffer[idx] = curCube;
		return;
	}

	//if the provided random spawn range encapsulates this cube, we need to spawn
	if (curCube.randomSeed.w < spawnRangeMax && curCube.randomSeed.w > spawnRangeMin) {
		//spawn somewhere between current position and last controller position (to prevent very visually apparent 'blobs' of spawned particles when controllers move quickly)
		float lerpFactor = (curCube.randomSeed.w - spawnRangeMin) / (spawnRangeMax - spawnRangeMin);
		
		//randomly choose between left or right, based on provided LR weighting
		if (curCube.randomSeed.w < LRSpawnBalance) {
			pos = controllerPositionL - controllerVelocityL * lerpFactor;
		}
		else {
			pos = controllerPositionR - controllerVelocityR * lerpFactor;
		}

		//set spawn parameters
		velocity = curCube.randomSeed.xyz * cubeSpawnVelocity;
		scale = spawnBuffer[idx].scale;
		curCube.color = spawnBuffer[idx].color;
		curCube.anchor = float4(pos, 0.0);
		curCube.pos.w = 0;

		outputBuffer[idx] = curCube;
	}
	else {

		float gravConst = 0.000006674;

		//we use these a lot
		float3 distL = (controllerPositionL.xyz - pos);
		float3 distR = (controllerPositionR.xyz - pos);
		float lengthL = length(distL);
		float lengthR = length(distR);
		float3 normL = normalize(distL);
		float3 normR = normalize(distR);

		lengthL = lengthL + softeningFactor;
		lengthR = lengthR + softeningFactor;
		distL = lengthL * normL;
		distR = lengthR * normR;

		float magL = controllerChargeL * gravConst / pow(lengthL, distanceExponent);
		float magR = controllerChargeR * gravConst / pow(lengthR, distanceExponent);
		float3 leftForce;
		float3 rightForce;
		float3 dampingForce = -1.0 * velocity * velocityDampening;


		//OLD WAY - DISPERSION DISTANCE
		//if (lengthL < softeningFactor) leftForce = float3(0, 0, 0);
		//else leftForce = normalize(distL) * ((controllerChargeL * gravConst) / pow(lengthL, distanceExponent));

		//if (lengthR < softeningFactor) rightForce = float3(0, 0, 0);
		//else rightForce = normalize(distR) * ((controllerChargeR * gravConst) / pow(lengthR, distanceExponent));

		//NEW WAY - SOFTENING FACTOR

		leftForce = normL * magL;
		rightForce = normR * magR;

		
		float3 omegaL = magL * controllerForwardL.xyz;
		float3 vortexForceLeft = cross(omegaL, distL);

		
		float3 omegaR = magR * controllerForwardR.xyz;
		float3 vortexForceRight = cross(omegaR, distR);

		leftForce = leftForce + vortexForceLeft * vortexStrength;
		rightForce = rightForce + vortexForceRight * vortexStrength;

		float3 forceSum = (leftForce + rightForce) * 90.0;

		float minAnchorVelocity = 0.0001;
		float anchorSetSpeed = 0.001;
		float maxK = 0.001;
		float breakForce = 0.00001;
		if (jellyMode == 1) {
			if (length(velocity) < minAnchorVelocity) {
				curCube.anchor = float4(pos, curCube.anchor.w + (maxK * particleMass - curCube.anchor.w) * anchorSetSpeed);
			}

			if (length(forceSum) > breakForce) {
				curCube.anchor.w = lerp(curCube.anchor.w, 0.0, anchorSetSpeed * 3);
			}

			float3 springForce = curCube.anchor.w * (curCube.anchor.xyz - pos);

			velocity = velocity + (springForce / particleMass) * finalTimeScale;
		}


		//velocity = velocity + straightVelocity;

		velocity = velocity + (forceSum / particleMass) * finalTimeScale;
		
		velocity = velocity + (dampingForce / particleMass) * finalTimeScale;

		//Update position
		curCube.pos = float4(pos + (velocity * finalTimeScale), age + finalTimeScale / fps);

		if (roomCollision == 1) {
			float velocityBounciness = 0.4;
			if (pos.y < 0) {
				pos.y = 0;
				velocity.y = velocity.y * -1 * velocityBounciness;
			}
			else if (pos.y > roomSize.y) {
				pos.y = roomSize.y;
				velocity.y = velocity.y * -1 * velocityBounciness;
			}
			if (pos.x < -roomSize.x * 0.5) {
				pos.x = -roomSize.x * 0.5;
				velocity.x = velocity.x * -1 * velocityBounciness;
			}
			else if (pos.x > roomSize.x * 0.5) {
				pos.x = roomSize.x * 0.5;
				velocity.x = velocity.x * -1 * velocityBounciness;
			}
			if (pos.z < -roomSize.z * 0.5) {
				pos.z = -roomSize.z * 0.5;
				velocity.z = velocity.z * -1 * velocityBounciness;
			}
			else if (pos.z > roomSize.z * 0.5) {
				pos.z = roomSize.z * 0.5;
				velocity.z = velocity.z * -1 * velocityBounciness;
			}
		}


		curCube.velocity = float4(velocity, 0);
		curCube.scale = float4(scale, 0);
		//Update buffer
		outputBuffer[idx] = curCube;
	}
}



[numthreads(32, 32, 1)]
void Graphics(uint3 id : SV_DispatchThreadID)
{
	//Get current ID
	int idx = id.x + (id.y * thread_group_x * thread_x) + (id.z * thread_group_x * thread_y * thread_group_y * thread_z);
	StarData curCube = outputBuffer[idx];

	//Get Color
	float4 col = float4(1, 1, 1, 1);

	float3 velocity = curCube.velocity.xyz;

	if (colorMode == 0) {
		if (length(velocity) > 0) {
			//Turn color into vector
			col = float4(normalize(velocity), 1.0) + float4(1.0, 1.0, 1.0, 1.0);
			col *= 0.5;
			if (length(col) > 0.8) { col.x = 1.0 - col.x; }
			col.a = 1.0;
			curCube.color = lerp(curCube.color, col, 0.1);
		}
	}
	else {
		float3 colA = float3(1,0,0);
		float3 colB = float3(0,1,0);

		if (colorMode == 1) {
			colA = float3(255, 0, 0) / 255.0;
			colB = float3(255, 206, 0) / 255.0;
		}
		else if (colorMode == 2) {
			colA = float3(0, 2, 255) / 255.0;
			colB = float3(0, 213, 255) / 255.0;
		}
		else if (colorMode == 3) {
			colA = float3(40, 186, 161) / 255.0;
			colB = float3(230, 255, 0) / 255.0;
		}
		else if (colorMode == 4) {
			colA = float3(199, 255, 239) / 255.0;
			colB = float3(163, 190, 255) / 255.0;
		}

		if (length(velocity) > 0) {
			float3 normVel = normalize(velocity) + float3(1, 1, 1);
			normVel *= 0.5;
			col = float4(lerp(colA.x, colB.x, normVel.x), lerp(colA.y, colB.y, normVel.y), lerp(colA.z, colB.z, normVel.z), 1.0);
			curCube.color = lerp(curCube.color, col, 0.1);
		}
	}

	if (customMode == 2) {
		float3 returnDisp = float3(0, 1.2, 0) - curCube.pos.xyz;
		float returnMag = length(returnDisp);
		if (returnMag > 0.8) {
			curCube.color = float4(0, 0, 0, 0);
		}
		else {
			float scale = returnMag / 0.8;
			curCube.color = lerp(float4(1, 1, 1, 0.5), float4(0, 0, 0, 0), scale);
		}
	}

	curCube.scale = float4(shipSize, 0);

	//Update buffer
	outputBuffer[idx] = curCube;
}