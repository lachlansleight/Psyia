// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Physics
#pragma kernel Graphics

#define thread_group_x 10
#define thread_group_y 10
#define thread_group_z 10

#define thread_x 10
#define thread_y 10
#define thread_z 10

//input data:

//controller and head positions
float4 controllerPositionL;
float4 controllerForwardL;
float4 controllerVelocityL;
float controllerChargeL;

float4 controllerPositionR;
float4 controllerForwardR;
float4 controllerVelocityR;
float controllerChargeR;

//Audio input
float bassAudio;
float midAudio;
float trebleAudio;
float avgAudio;

//Spawn parameters
float spawnRangeMin;
float spawnRangeMax;
float LRSpawnBalance;

//time parameters
float timeScale;
float fps;
float time;

//physics parameters
float velocityDampening;
float softeningFactor;
float particleMass;
float distanceExponent;
float vortexStrength;
float cubeSpawnVelocity;
//note - these were hard to tune, so I think I'll leave them hardcoded
//float minAnchorVelocity;
//float anchorSetSpeed;
//float maxK;
//float breakForce;
int roomCollision;
int jellyMode;
float3 roomSize;
float3 shipSize;

//visual parameters
int colorMode;

int customMode;
float burstLaunchVelocity;
float returnPullForce;

struct StarData {
	float3 pos;
	float3 velocity;
	float3 scale;
	float4 color;
	float4 randomSeed;
	float4 anchor;
	float age;
};

RWStructuredBuffer<StarData> outputBuffer;
RWStructuredBuffer<StarData> spawnBuffer;

[numthreads(10, 10, 10)]
void Physics(uint3 id : SV_DispatchThreadID)
{
	int idx = id.x + (id.y * thread_group_x * thread_x) + (id.z * thread_group_x * thread_y * thread_group_y * thread_z);
	StarData curCube = outputBuffer[idx];

	float finalTimeScale = timeScale * (90.0 / fps);

	//pause
	if (customMode == -1) {
		return;
	}

	//disperse
	if (customMode == 1) {
		curCube.pos = float3(0, 1.2, 0);
		curCube.velocity = curCube.randomSeed.xyz * burstLaunchVelocity;
		outputBuffer[idx] = curCube;
		return;
	}
	//go back to 0,1.2,0
	else if (customMode == 2) {
		float3 returnDisp = float3(0, 1.2, 0) - curCube.pos;
		float3 returnNorm = normalize(returnDisp);
		float returnMag = length(returnDisp);

		float3 returnForce = (returnNorm * returnPullForce) / (returnMag + softeningFactor);
		curCube.velocity = curCube.velocity + (returnForce / particleMass) * finalTimeScale;

		//make sure we don't overshoot by clamping velocity as we approach
		float3 newReturnDisp = float3(0, 1.2, 0) - (curCube.pos + (curCube.velocity * finalTimeScale));
		if (returnMag < length(newReturnDisp)) {
			curCube.velocity = (float3(0, 1.2, 0) - curCube.pos) / finalTimeScale;
		}
		curCube.pos = curCube.pos + (curCube.velocity * finalTimeScale);
		outputBuffer[idx] = curCube;
		return;
	}

	//if the provided random spawn range encapsulates this cube, we need to spawn
	if (curCube.randomSeed.w < spawnRangeMax && curCube.randomSeed.w > spawnRangeMin) {
		//spawn somewhere between current position and last controller position (to prevent very visually apparent 'blobs' of spawned particles when controllers move quickly
		float lerpFactor = (curCube.randomSeed.w - spawnRangeMin) / (spawnRangeMax - spawnRangeMin);
		
		//randomly choose between left or right, based on provided LR weighting
		if (curCube.randomSeed.w < LRSpawnBalance) {
			curCube.pos = controllerPositionL - controllerVelocityL * lerpFactor;
		}
		else {
			curCube.pos = controllerPositionR - controllerVelocityR * lerpFactor;
		}

		//set spawn parameters
		curCube.velocity = curCube.randomSeed.xyz * cubeSpawnVelocity;
		curCube.scale = spawnBuffer[idx].scale;
		curCube.color = spawnBuffer[idx].color;
		curCube.anchor = float4(curCube.pos, 0.0);
		curCube.age = 0;

		outputBuffer[idx] = curCube;
	}
	else {

		float gravConst = 0.000006674;

		//we use these a lot
		float3 distL = controllerPositionL.xyz - curCube.pos;
		float3 distR = controllerPositionR.xyz - curCube.pos;
		float lengthL = length(distL);
		float lengthR = length(distR);
		float3 normL = normalize(distL);
		float3 normR = normalize(distR);

		float3 leftForce;
		float3 rightForce;
		float3 dampingForce = -1.0 * curCube.velocity * velocityDampening;


		//OLD WAY - DISPERSION DISTANCE
		//if (lengthL < softeningFactor) leftForce = float3(0, 0, 0);
		//else leftForce = normalize(distL) * ((controllerChargeL * gravConst) / pow(lengthL, distanceExponent));

		//if (lengthR < softeningFactor) rightForce = float3(0, 0, 0);
		//else rightForce = normalize(distR) * ((controllerChargeR * gravConst) / pow(lengthR, distanceExponent));

		//NEW WAY - SOFTENING FACTOR
		distL = distL * (1.0 + softeningFactor);
		distR = distR * (1.0 + softeningFactor);
		lengthL = lengthL + softeningFactor;
		lengthR = lengthR + softeningFactor;
		leftForce = normL * ((controllerChargeL * gravConst) / pow(lengthL, distanceExponent));
		rightForce = normR * ((controllerChargeR * gravConst) / pow(lengthR, distanceExponent));

		float magL = controllerChargeL * gravConst / pow(lengthL, distanceExponent);
		float3 omegaL = magL * controllerForwardL.xyz;
		float3 vortexForceLeft = cross(omegaL, distL);

		float magR = controllerChargeR * gravConst / pow(lengthR, distanceExponent);
		float3 omegaR = magR * controllerForwardR.xyz;
		float3 vortexForceRight = cross(omegaR, distR);

		leftForce = leftForce + vortexForceLeft * vortexStrength;
		rightForce = rightForce + vortexForceRight * vortexStrength;

		float3 forceSum = (leftForce + rightForce) * 90.0;

		float minAnchorVelocity = 0.0001;
		float anchorSetSpeed = 0.001;
		float maxK = 0.001;
		float breakForce = 0.00001;
		if (jellyMode == 1) {
			if (length(curCube.velocity) < minAnchorVelocity) {
				curCube.anchor = float4(curCube.pos, curCube.anchor.w + (maxK * particleMass - curCube.anchor.w) * anchorSetSpeed);
			}

			if (length(forceSum) > breakForce) {
				curCube.anchor.w = lerp(curCube.anchor.w, 0.0, anchorSetSpeed * 3);
			}

			float3 springForce = curCube.anchor.w * (curCube.anchor.xyz - curCube.pos);

			curCube.velocity = curCube.velocity + (springForce / particleMass) * finalTimeScale;
		}


		//curCube.velocity = curCube.velocity + straightVelocity;

		curCube.velocity = curCube.velocity + (forceSum / particleMass) * finalTimeScale;
		
		curCube.velocity = curCube.velocity + (dampingForce / particleMass) * finalTimeScale;

		//Update position
		curCube.pos = curCube.pos + (curCube.velocity * finalTimeScale);

		if (roomCollision == 1) {
			int bounce = 0;
			float velocityBounciness = 0.4;
			if (curCube.pos.y < 0) {
				curCube.pos.y = 0;
				curCube.velocity.y = curCube.velocity.y * -1;
				bounce = 1;
			}
			else if (curCube.pos.y > roomSize.y) {
				curCube.pos.y = roomSize.y;
				curCube.velocity.y = curCube.velocity.y * -1;
				bounce = 1;
			}
			if (curCube.pos.x < -roomSize.x * 0.5) {
				curCube.pos.x = -roomSize.x * 0.5;
				curCube.velocity.x = curCube.velocity.x * -1;
				bounce = 1;
			}
			else if (curCube.pos.x > roomSize.x * 0.5) {
				curCube.pos.x = roomSize.x * 0.5;
				curCube.velocity.x = curCube.velocity.x * -1;
				bounce = 1;
			}
			if (curCube.pos.z < -roomSize.z * 0.5) {
				curCube.pos.z = -roomSize.z * 0.5;
				curCube.velocity.z = curCube.velocity.z * -1;
				bounce = 1;
			}
			else if (curCube.pos.z > roomSize.z * 0.5) {
				curCube.pos.z = roomSize.z * 0.5;
				curCube.velocity.z = curCube.velocity.z * -1;
				bounce = 1;
			}

			if (bounce > 0) {
				curCube.velocity = curCube.velocity * velocityBounciness;
			}
		}

		curCube.age = curCube.age + finalTimeScale / fps;

		//Update buffer
		outputBuffer[idx] = curCube;
	}
}



[numthreads(10, 10, 10)]
void Graphics(uint3 id : SV_DispatchThreadID)
{
	//Get current ID
	int idx = id.x + (id.y * thread_group_x * thread_x) + (id.z * thread_group_x * thread_y * thread_group_y * thread_z);
	StarData curCube = outputBuffer[idx];

	//Get Color
	float4 col = float4(1, 1, 1, 1);

	if (colorMode == 0) {
		if (length(curCube.velocity) > 0) {
			//Turn color into vector
			col = float4(normalize(curCube.velocity), 1.0) + float4(1.0, 1.0, 1.0, 1.0);
			col *= 0.5;
			if (length(col) > 0.8) { col.x = 1.0 - col.x; }
			col.a = 1.0;
			curCube.color = lerp(curCube.color, col, 0.1);
		}
	}
	else {
		float3 colA = float3(1,0,0);
		float3 colB = float3(0,1,0);

		if (colorMode == 1) {
			colA = float3(255, 0, 0) / 255.0;
			colB = float3(255, 206, 0) / 255.0;
		}
		else if (colorMode == 2) {
			colA = float3(0, 2, 255) / 255.0;
			colB = float3(0, 213, 255) / 255.0;
		}
		else if (colorMode == 3) {
			colA = float3(40, 186, 161) / 255.0;
			colB = float3(230, 255, 0) / 255.0;
		}
		else if (colorMode == 4) {
			colA = float3(199, 255, 239) / 255.0;
			colB = float3(163, 190, 255) / 255.0;
		}

		if (length(curCube.velocity) > 0) {
			float3 normVel = normalize(curCube.velocity) + float3(1, 1, 1);
			normVel *= 0.5;
			col = float4(lerp(colA.x, colB.x, normVel.x), lerp(colA.y, colB.y, normVel.y), lerp(colA.z, colB.z, normVel.z), 1.0);
			curCube.color = lerp(curCube.color, col, 0.1);
		}
	}

	curCube.scale = shipSize;

	//Update buffer
	outputBuffer[idx] = curCube;
}